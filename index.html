<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>크로스워드 생성기</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
       @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&family=Funnel+Sans:ital,wght@0,300..800;1,300..800&display=swap'); /* Noto Sans KR과 Funnel Sans 폰트 모두 가져오기 */
       @import url('https://fonts.googleapis.com/css2?family=Bagel+Fat+One&display=swap'); /* Bagel Fat One 폰트 가져오기 */

        body {
            font-family: 'Funnel Sans', 'Noto Sans KR', sans-serif; /* 영어는 Funnel Sans, 한글은 Noto Sans KR 사용 */
            letter-spacing: -0.03em; /* 한글 폰트 자간 미세 조정 */
            max-width: 1200px;
            margin: 0 auto;
            padding: 40px;
            background: #F1F6F9; /* 배경을 쿨그레이 단색으로 변경 */
            min-height: 100vh;
            color: #333;
            font-weight: 400; /* 기본 폰트 굵기를 400(normal)로 명시 */
        }
        
        .container {
            background: white;
            border-radius: 40px;
            padding: 30px;
        }
        
        h1 {
            font-family: 'Bagel Fat One', 'Noto Sans KR', sans-serif; /* H1 폰트를 Bagel Fat One으로 설정 */
            text-align: center;
            color: #DFF0FC;
            margin-bottom: 40px;
            font-size: 60px;
            font-weight: 400;
            letter-spacing: 0em;
            background: none; 
            -webkit-background-clip: unset;
            -webkit-text-fill-color: #174374;
        }
        
        .controls {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
        }
        
        button {
            padding: 14px 32px; 
            border: none;
            border-radius: 16px; /* 버튼 모서리를 더 둥글게 변경 */
            font-size: 16px;
            font-weight: 500; 
            text-transform: none; /* 대문자 변환 제거 (원래 텍스트 그대로 사용) */
            letter-spacing: -0.03em; 
            cursor: pointer;
            transition: all 0.3s ease;
            background: #a0aec0; /* 쿨그레이 색상으로 변경 */
            color: white;
            box-shadow: none; 
            font-family: 'Noto Sans KR', sans-serif; /* 버튼 폰트를 Noto Sans KR로 통일 */
        }

        /* 개별 버튼 색상 및 텍스트 오버라이드 */
        #generateButton { /* 퍼즐 생성 버튼 ID 추가 */
            background-color: #174374; /* 연한 파란색 배경 */
            color: white; /* 짙은 파란색 텍스트 */
            border:  none; /* 연한 파란색 테두리 */
        }

        #downloadBtn { /* PDF 저장 버튼 ID 유지 */
            background-color: #174374; /* 연한 파란색 배경 */
            color: white; /* 짙은 파란색 텍스트 */
            border: none; /* 연한 파란색 테두리 */
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: none; 
        }
        
        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        
        .crossword-container {
            display: flex;
            flex-direction: column; 
            gap: 30px; 
            margin-top: 30px;
        }
        
        .grid-container {
            position: relative; 
            flex: none; 
            min-width: 320px;
            max-width: 450px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 auto; 
            padding-bottom: 20px; 
        }
        
        .crossword-grid {
            display: grid;
            gap: 1px;
            background-color: #333;
            border: 2px solid #333;
            margin-bottom: 20px;
            width: fit-content;
        }
        
        .cell {
            background-color: #e0e7ee;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px; 
            font-weight: 500; 
            position: relative;
            border: 1px solid #a0aec0;
            box-sizing: border-box;
            box-shadow: inset 0 0 3px rgba(0,0,0,0.05);
            letter-spacing: 0.02em; 
        }
        
        .cell.black {
            background-color: #333;
            border: none;
            box-shadow: none;
        }
        
        .cell .number {
            position: absolute;
            top: 1px;
            left: 1px;
            font-size: 8px;
            color: #666;
        }
        
        .words-section {
            flex: none; 
            min-width: 280px;
            width: 100%; 
            padding-left: 0; 
            text-align: left; 
            box-sizing: border-box; 
        }
        
        
        .word-list {
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; /* 단어 아이템들을 가로 가운데 정렬 */
            gap: 8px;
            padding: 0;
            list-style: none;
            width: 100%; 
            margin: 0 auto; /* 리스트 자체를 중앙 정렬 */
        }
        
        .word-list li {
            background: #F4F4F5;
            padding: 6px 10px;
            border-radius: 6px;
            text-align: center;
            font-weight: 500; 
            border: none; 
            transition: all 0.2s ease;
            font-size: 0.9em;
            overflow-wrap: break-word;
            letter-spacing: 0.02em; 
        }
        
        .word-list li:hover {
            background: #e3f2fd;
            border-color: #667eea;
        }
        
        .loading {
            text-align: center;
            color: #174374;
            font-size: 16px;
            margin: 60px 60px;
            font-weight: 500;
        }
        
        /* 모달 스타일 */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 30px;
            border: 1px solid #888;
            border-radius: 15px;
            width: 80%;
            max-width: 400px;
            text-align: center;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            position: absolute;
            top: 10px;
            right: 15px;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }
        .modal-message {
            margin-bottom: 20px;
            font-size: 1.1em;
            color: #444;
        }

        /* 푸터 스타일 */
        .footer {
            text-align: center;
            margin-top: 30px;
            padding: 15px;
            font-size: 0.85em;
            color: #174374;
            padding-top: 25px; 
        }

        .footer span {
            font-weight: bold;
            color: #555;
        }

        /* 토글 스위치 스타일 */
        .toggle-switch-container {
            position: absolute;
            bottom: 0px; 
            right: -10px; 
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 10;
            background: white; 
            padding: 0px; 
            border-radius: 8px;
            box-shadow: none; 
        }

        .switch {
          position: relative;
          display: inline-block;
          width: 40px;
          height: 24px;
        }

        .switch input {
          opacity: 0;
          width: 0;
          height: 0;
        }

        .slider {
          position: absolute;
          cursor: pointer;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background-color: #E2E8EF; 
          -webkit-transition: .4s;
          transition: .4s;
        }

        .slider:before {
          position: absolute;
          content: "";
          height: 16px;
          width: 16px;
          left: 4px;
          bottom: 4px;
          background-color: white;
          -webkit-transition: .4s;
          transition: .4s;
        }

        input:checked + .slider {
          background-color: #174374; /* 켜진 상태 색상 (버튼과 동일) */
        }

        input:focus + .slider {
          box-shadow: 0 0 1px #a0aec0;
        }

        input:checked + .slider:before {
          -webkit-transform: translateX(16px);
          -ms-transform: translateX(16px);
          transform: translateX(16px);
        }

        /* Rounded sliders */
        .slider.round {
          border-radius: 24px;
        }

        .slider.round:before {
          border-radius: 50%;
        }

        .toggle-label {
            font-family: 'Noto Sans KR', sans-serif; /* 한글 폰트 적용 */
            font-size: 14px;
            color: #174374;
            font-weight: 500;
            letter-spacing: -0.03em; /* 한글 자간 통일 */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>크로스워드 생성기</h1>
        
        <div class="controls">
            <button onclick="generateCrossword()" id="generateButton">새 퍼즐</button>
            <button onclick="downloadPDF()" id="downloadBtn" disabled>PDF 저장</button>
            <!-- 정답 토글 버튼은 아래 grid-container 안으로 이동 -->
        </div>
        
        <div id="loading" class="loading" style="display: none;">
            크로스워드 생성 중 ⏳
        </div>
        
        <div class="crossword-container" id="crosswordContainer" style="display: none;">
            <div class="grid-container">
                <div id="crosswordGrid" class="crossword-grid"></div>
                <!-- 정답 토글 스위치 -->
                <div class="toggle-switch-container">
                    <span id="toggleLabel" class="toggle-label">정답 보기</span> <!-- 라벨을 스위치 왼쪽으로 이동 -->
                    <label class="switch">
                        <input type="checkbox" id="answerToggleCheckbox" onchange="toggleAnswerView()">
                        <span class="slider round"></span>
                    </label>
                </div>
            </div>
            
            <div class="words-section">
                <h3></h3>
                <ul id="wordList" class="word-list"></ul>
            </div>
        </div>
    </div>

    <!-- Custom Modal for Alerts -->
    <div id="myModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close-button" onclick="closeModal()">&times;</span>
            <p id="modalMessage" class="modal-message"></p>
            <button onclick="closeModal()">확인</button>
        </div>
    </div>

    <footer class="footer">
        Copyright © 2025 Sieun Choi. All rights reserved.
    </footer>

    <script>
        // Challenging word database (intermediate to advanced words)
        // 도전적인 단어 데이터베이스 (중급~고급 단어 중심)
        const wordDatabase = [
            // 3-4 letter simple words (3-4 글자 간단한 단어)
            'CAT', 'DOG', 'SUN', 'MOON', 'RUN', 'JUMP', 'BLUE', 'RED', 'FISH', 'BIRD',
            'TREE', 'CAR', 'BOOK', 'OPEN', 'CLOSE', 'DAY', 'NIGHT', 'READ', 'SING', 'PLAY',
            'FOOD', 'WATER', 'FIRE', 'HOME', 'LOVE', 'DARK', 'LIGHT', 'STAR', 'WALK', 'TALK',
            'GAME', 'TOWN', 'CITY', 'ROAD', 'GATE', 'HOPE', 'FREE', 'CUTE', 'LOUD', 'QUIZ',
            'LAMP', 'MAP', 'BAG', 'BOX', 'COIN', 'CUP', 'EAR', 'EYE', 'FARM', 'GIFT',
            'HAT', 'ICE', 'JET', 'KEY', 'LION', 'MILK', 'NEST', 'OWL', 'PIG', 'RAIN',
            'ROSE', 'SALT', 'TAPE', 'VASE', 'WIND', 'YARN', 'ZINC', 'ANT', 'BUS', 'DISH',
            'EGG', 'FAN', 'FOX', 'GOAT', 'HEN', 'INK', 'JAM', 'KITE', 'LEG', 'MAT',
            'NUT', 'OAR', 'PEN', 'QUILL', 'RING', 'SODA', 'TENT', 'VAN', 'WEB', 'YOGA',
            'ZOO', 'BEAR', 'CAKE', 'DICE', 'DUCK', 'FISH', 'FROG', 'GUM', 'HORN', 'IRON',
            'JUICE', 'KICK', 'LAKE', 'MINT', 'MOTH', 'NAIL', 'OVAL', 'PUMP', 'QUIT', 'ROOT',
            'SOAP', 'TAXI', 'TRAY', 'VOTE', 'WOLF', 'YAWN', 'ZERO',
            
            // 5-7 letter intermediate words (5-7 글자 중급 단어)
            'APPLE', 'BRAVE', 'CLOUDS', 'DREAM', 'EAGLE', 'FANCY', 'GRAPE', 'HAPPY', 'IDEAL', 'JOLLY',
            'KITES', 'LIGHT', 'MAGIC', 'NIGHT', 'OCEAN', 'PEACE', 'QUIET', 'RIVER', 'STORY', 'TIGER',
            'UNION', 'VIOLET', 'WALRUS', 'XENON', 'YIELD', 'ZONES', 'AMONG', 'BEACH', 'CRANE', 'DAISY',
            'ENJOY', 'FROGS', 'GIANT', 'HASTY', 'IMAGE', 'JEWEL', 'KNEEL', 'LEMON', 'MOOSE', 'NOBLE',
            'OASIS', 'PLUTO', 'QUICK', 'ROBIN', 'SNAIL', 'TRUTH', 'ULTRA', 'VITAL', 'WAVES', 'YOUTH',
            'ZEBRA', 'QUEST', 'BLAZE', 'FJORD', 'WALTZ', 'JUDGE', 'PROXY', 'QUOTE', 'WHISK', 'BRISK',
            'QUILT', 'YACHT', 'SPHINX', 'RHYTHM', 'GALAXY', 'FROZEN', 'SYNTAX', 'OXYGEN', 'ENZYME', 'MATRIX',
            'FABRIC', 'WISDOM', 'SEQUEL', 'KNIGHT', 'VOYAGE', 'BEACON', 'ENIGMA', 'TEMPLE', 'SPHERE', 'BRONZE',
            'AUTUMN', 'MARBLE', 'JUNGLE', 'FLAVOR', 'GENIUS', 'PORTAL', 'VERTEX', 'ORCHID', 'MAGNET', 'CORPUS',
            
            // 8-10 letter upper-intermediate words (8-10 글자 중상급 단어)
            'ABSTRACT', 'BEHAVIOR', 'COMPUTER', 'DIALOGUE', 'EXCHANGE', 'FUNCTION', 'GRAPHICS', 'HOSPITAL',
            'IDENTITY', 'JEALOUSY', 'KEYBOARD', 'LANGUAGE', 'MAGNETIC', 'NEGATIVE', 'OBJECTIVE', 'PAVILION',
            'QUANTITY', 'RESEARCH', 'SANDWICH', 'TRIANGLE', 'UMBRELLA', 'VELOCITY', 'WORKSHOP', 'XYLOPHONE',
            'YEARBOOK', 'ZEPPELIN', 'BACTERIA', 'CAMPAIGN', 'DESIGNER', 'EQUATION', 'FESTIVAL',
            'GRACEFUL', 'HANDBOOK', 'IDENTIFY', 'JUNCTION', 'KANGAROO', 'LANDMARK', 'MAGAZINE', 'NOTEBOOK',
            'ELEPHANT', 'SPECTRUM', 'TWILIGHT', 'UNIVERSE', 'VARIABLE', 'WIRELESS', 'ACADEMIC',
            'BASEMENT', 'CREATURE', 'DIAMOND', 'FOUNTAIN', 'GARDENER', 'INCIDENT',
            'JOYSTICK', 'NONSENSE', 'OBSTACLE', 'PARADISE', 'QUESTION', 'ABUNDANT', 'CAPTURED', 'DECORATE',
            'ELEGANCE', 'FANTASTIC', 'GENEROUS', 'HARMONY', 'ILLUSION', 'JOURNAL', 'LUSCIOUS', 'MYSTERIOUS',
            'NARRATOR', 'OVERCOME', 'POSITIVE', 'QUALIFIED', 'RADIANCE', 'SERENITY', 'TREASURE', 'UNDERTAKE',
            'VIBRANT', 'WONDERFUL', 'YACHTING', 'ADVENTURE', 'BRILLIANT', 'CHAMPION', 'DISCOVER', 'ESSENCE',

            // Academic/Technical terms (학술/기술 용어) - 10글자 이하 유지
            'ALGORITHM', 'BANDWIDTH', 'CHEMISTRY', 'DATABASE', 'ECOSYSTEM', 'FRAMEWORK', 'GENETICS', 'HISTOGRAM',
            'INTERFACE', 'JAVASCRIPT', 'KINEMATIC', 'LOGISTICS', 'MICROWAVE', 'NEUROLOGY', 'ORCHESTRA', 'PROTOCOL',
            'QUARANTINE', 'RADIATION', 'SYNTHESIS', 'TELESCOPE', 'VOCABULARY', 'WAVELENGTH', 'XEROGRAPHY',
            'ZOOLOGY', 'CRYPTOGRAPHY', 'DEMOGRAPHICS', 'SEISMOLOGY',
            'QUANTUM', 'ROBOTICS', 'STATISTICS', 'TECHNOLOGY', 'VIRTUAL', 'WIKIPEDIA', 'YOUTUBE',
            'ZIGZAG', 'ANALYSIS', 'BIOLOGY', 'CALCULUS', 'DATASET', 'FORMULA', 'GEOMETRY', 'HYPOTHESIS',
            'INNOVATION', 'JUNCTURE', 'LABORATORY', 'METADATA', 'NEUTRONS', 'OPTICS', 'PARADIGM', 'QUOTIENT', 'RESOLUTION',
            
            // Advanced adjectives/adverbs (고급 형용사/부사) - 10글자 이하 유지
            'MAGNIFICENT', 'SPECTACULAR', 'TREMENDOUS', 'INCREDIBLE', 'OUTSTANDING', 'REMARKABLE',
            'EXCEPTIONAL', 'PHENOMENAL', 'ASTONISHING', 'BREATHTAKING', 'OVERWHELMING', 'UNPRECEDENTED',
            'SOPHISTICATED', 'COMPREHENSIVE', 'EXPERIMENTAL',
            'FUNDAMENTAL', 'INTELLECTUAL', 'PROFESSIONAL', 'TECHNOLOGICAL', 'PHILOSOPHICAL', 'PSYCHOLOGICAL',
            'ABSOLUTELY', 'ACCURATELY', 'ADAPTIVELY', 'BEAUTIFULLY', 'CAREFULLY', 'COMPLETELY', 'CONSISTENTLY',
            'DEFINITELY', 'EFFORTLESSLY', 'ESPECIALLY', 'EXACTLY', 'EXTENSIVELY', 'FREQUENTLY', 'GRADUALLY',
            'IMMEDIATELY', 'INCREASINGLY', 'INNOVATIVELY', 'LEGITIMATELY', 'NECESSARILY', 'OPTIMALLY', 'PARTICULARLY',
            'POTENTIALLY', 'PRECISELY', 'RAPIDLY', 'RELIABLY', 'SIGNIFICANTLY', 'SUCCESSFULLY', 'ULTIMATELY',
            
            // Compound words/Specialized terms (복합어/전문 용어) - 10글자 이하 유지
            'BREAKTHROUGH', 'MARKETPLACE', 'SPOKESPERSON', 'HEADQUARTERS',
            'NEVERTHELESS', 'FURTHERMORE', 'CONSEQUENCE', 'SIGNIFICANCE', 'MAINTENANCE', 'PERFORMANCE',
            'ARCHITECTURE', 'MATHEMATICS', 'PHOTOGRAPHY', 'BIBLIOGRAPHY', 'CHOREOGRAPHY',
            'AUTOBIOGRAPHY', 'CHAMPIONSHIP', 'RELATIONSHIP', 'WORKMANSHIP',
            'ENCYCLOPEDIA', 'THUNDERSTORM', 'GRASSHOPPER', 'TOOTHBRUSH', 'EARTHQUAKE',
            'BACKGROUND', 'BASKETBALL', 'BUTTERFLY', 'CAREFREE', 'DAYLIGHT', 'DOORWAY', 'EVERYTHING', 'FIREFLY',
            'FORECAST', 'GOLDFISH', 'GRANDCHILD', 'HEADLIGHT', 'HOUSEPLANT', 'KEYSTONE', 'LANDSCAPE', 'LIFETIME',
            'MOONLIGHT', 'OUTSTANDING', 'OVERNIGHT', 'PASSPORT', 'RAINDROP', 'SEASHELL', 'SUNFLOWER', 'TEACUP',
            'UNDERWATER', 'WATERFALL', 'WITHOUT', 'WORKOUT', 'ZIPPER'
        ];

        let currentGrid = null;
        let currentWords = null;
        let answerGrid = null;
        let showingAnswer = false;
        const GRID_SIZE = 21; // 통일된 그리드 크기

        // 커스텀 모달을 표시하는 함수
        function showModal(message) {
            document.getElementById('modalMessage').textContent = message;
            document.getElementById('myModal').style.display = 'flex'; // 중앙 정렬을 위해 flex 사용
        }

        // 커스텀 모달을 닫는 함수
        function closeModal() {
            document.getElementById('myModal').style.display = 'none';
        }

        // 크로스워드를 생성하는 함수
        function generateCrossword() {
            document.getElementById('loading').style.display = 'block';
            document.getElementById('crosswordContainer').style.display = 'none';
            document.getElementById('downloadBtn').disabled = true;
            
            // 토글 스위치 비활성화 및 초기화
            const toggleCheckbox = document.getElementById('answerToggleCheckbox');
            const toggleLabel = document.getElementById('toggleLabel');
            toggleCheckbox.disabled = true;
            toggleCheckbox.checked = false; // 항상 비활성화 상태로 시작
            toggleLabel.textContent = '정답 보기';
            
            // 컨테이너를 먼저 보이게 하여 offsetWidth가 올바르게 계산되도록 함
            document.getElementById('crosswordContainer').style.display = 'flex'; 

            setTimeout(() => {
                const result = createFillInCrossword(GRID_SIZE);
                
                // 충분한 단어가 배치되었는지 확인
                if (result && result.words.length > 10) { // 최소 10개 이상 단어가 배치되어야 성공으로 간주
                    currentGrid = result.emptyGrid;
                    answerGrid = result.answerGrid;
                    currentWords = result.words;
                    showingAnswer = false; // 퍼즐 뷰로 시작
                    displayCrossword(currentGrid, currentWords, GRID_SIZE); // 빈 그리드 표시
                    document.getElementById('downloadBtn').disabled = false;
                    toggleCheckbox.disabled = false; // 토글 스위치 활성화
                    
                    // 퍼즐 생성 후 기본적으로 힌트 글자 하나 공개
                    revealHintLetterInternal(); 

                } else {
                    // 생성 실패 시 모달 메시지 표시
                    showModal('크로스워드 생성에 실패했습니다. (충분한 단어가 배치되지 않음) 다시 시도해주세요.');
                    document.getElementById('crosswordContainer').style.display = 'none'; // 실패 시 컨테이너 숨김
                    toggleCheckbox.disabled = true; // 토글 스위치 비활성화
                    toggleCheckbox.checked = false;
                    toggleLabel.textContent = '정답 보기';
                }
                
                document.getElementById('loading').style.display = 'none';
            }, 1500);
        }

        // 채워넣기 크로스워드를 생성하는 핵심 로직
        function createFillInCrossword(size) {
            const grid = Array(size).fill(null).map(() => Array(size).fill(''));
            const answerGrid = Array(size).fill(null).map(() => Array(size).fill(''));
            const emptyGrid = Array(size).fill(null).map(() => Array(size).fill(''));
            const usedWords = [];
            
            // 단어 데이터베이스를 섞고 길이(3~10자)에 따라 필터링
            let shuffledAndFilteredWords = [...wordDatabase]
                .filter(word => word.length >= 3 && word.length <= 10)
                .sort(() => Math.random() - 0.5); // 단어를 한 번만 섞습니다.

            if (shuffledAndFilteredWords.length === 0) return null; // 배치할 단어가 없으면 null 반환

            // 1. 첫 번째 단어 배치 (무작위로 선택)
            const firstWord = shuffledAndFilteredWords.shift(); // 섞인 리스트에서 첫 단어를 가져옵니다.
            const startRow = Math.floor(size / 2);
            const startCol = Math.floor((size - firstWord.length) / 2);
            
            if (firstWord && startCol >= 0 && startCol + firstWord.length <= size) {
                for (let i = 0; i < firstWord.length; i++) {
                    grid[startRow][startCol + i] = firstWord[i];
                    answerGrid[startRow][startCol + i] = firstWord[i];
                }
                usedWords.push(firstWord);
            } else {
                return null; // 첫 단어를 배치할 수 없으면 null 반환
            }

            // 2. 남은 단어들을 교차점을 찾아 배치 시도 (목표 개수까지)
            const targetWordCount = 40; 

            for (const word of shuffledAndFilteredWords) { // 남은 섞인 단어들을 순회
                if (usedWords.length >= targetWordCount) break; // 목표 개수에 도달하면 중단

                const placement = findIntersection(grid, word, size);
                
                if (placement) {
                    placeWord(grid, word, placement);
                    placeWord(answerGrid, word, placement);
                    usedWords.push(word);
                }
            }
            
            // 빈 그리드 생성 (빈 칸은 검은 셀, 채워진 칸은 빈 플레이 가능한 셀)
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (grid[row][col] === '') {
                        emptyGrid[row][col] = ''; // 검은 셀
                    } else {
                        emptyGrid[row][col] = ' '; // 빈 플레이 가능 셀
                    }
                }
            }
            
            return { 
                emptyGrid: emptyGrid, 
                answerGrid: answerGrid, 
                words: usedWords.sort((a, b) => a.length - b.length || a.localeCompare(b)) // 사용된 단어 정렬
            };
        }

        // 단어가 그리드에 교차할 수 있는 위치를 찾는 함수
        function findIntersection(grid, word, size) {
            const validPlacements = [];
            
            // 기존 그리드 셀을 순회
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    if (grid[row][col] && grid[row][col] !== '') { // 셀에 글자가 있으면
                        const gridLetter = grid[row][col];
                        
                        // 현재 단어가 이 글자를 포함하는지 확인
                        for (let i = 0; i < word.length; i++) {
                            if (word[i] === gridLetter) {
                                // 가로 배치 시도
                                const hCol = col - i;
                                if (canPlaceHorizontal(grid, word, row, hCol, size)) {
                                    validPlacements.push({
                                        row: row,
                                        col: hCol,
                                        direction: 'across'
                                    });
                                }
                                
                                // 세로 배치 시도
                                const vRow = row - i;
                                if (canPlaceVertical(grid, word, vRow, col, size)) {
                                    validPlacements.push({
                                        row: vRow,
                                        col: col,
                                        direction: 'down'
                                    });
                                }
                            }
                        }
                    }
                }
            }
            
            // 유효한 배치 중 무작위 하나를 반환, 없으면 null 반환
            return validPlacements.length > 0 ? validPlacements[Math.floor(Math.random() * validPlacements.length)] : null;
        }

        // 단어를 가로로 배치할 수 있는지 확인하는 함수
        function canPlaceHorizontal(grid, word, row, col, size) {
            // 1. 경계 확인
            if (col < 0 || col + word.length > size || row < 0 || row >= size) return false;
            
            // 2. 단어 시작/끝 부분에 다른 단어가 붙는지 확인 (Edge conflicts)
            // (교차점은 허용됨. 이는 아래 3번에서 처리)
            if (col > 0 && grid[row][col - 1] !== '') { // 바로 왼쪽 칸이 비어있지 않다면
                // 이 칸이 배치하려는 단어의 일부(교차점)가 아니라면 false (중복 방지)
                if (grid[row][col-1] !== word[0]) { // 첫 글자와 왼쪽 칸이 일치하지 않으면
                     return false; 
                }
            }
            if (col + word.length < size && grid[row][col + word.length] !== '') { // 바로 오른쪽 칸이 비어있지 않다면
                // 이 칸이 배치하려는 단어의 일부(교차점)가 아니라면 false (중복 방지)
                if (grid[row][col + word.length] !== word[word.length - 1]) { // 마지막 글자와 오른쪽 칸이 일치하지 않으면
                    return false;
                }
            }
            
            // 3. 각 셀을 순회하며 충돌 검사 (Conflict checking and intersections)
            for (let i = 0; i < word.length; i++) {
                const currentGridChar = grid[row][col + i]; // 현재 그리드의 해당 셀 글자
                const newWordChar = word[i]; // 배치하려는 단어의 해당 글자

                // 셀이 비어있지 않은데, 배치하려는 글자와 다르다면 충돌
                if (currentGridChar !== '' && currentGridChar !== newWordChar) {
                    return false;
                }
                
                // 4. 수직 방향 인접 셀 검사 (Perpendicular adjacency check)
                // 현재 셀이 비어 있으면 위아래 셀에 다른 글자가 없는지 확인 (L-자 형태 방지)
                if (currentGridChar === '') { 
                    // 위쪽 셀 확인
                    if (row > 0 && grid[row - 1][col + i] !== '') {
                        return false;
                    }
                    // 아래쪽 셀 확인
                    if (row < size - 1 && grid[row + 1][col + i] !== '') {
                        return false;
                    }
                }
            }
            return true;
        }

        // 단어를 세로로 배치할 수 있는지 확인하는 함수
        function canPlaceVertical(grid, word, row, col, size) {
            // 1. 경계 확인
            if (row < 0 || row + word.length > size || col < 0 || col >= size) return false;
            
            // 2. 단어 위/아래 부분에 다른 단어가 붙는지 확인
            if (row > 0 && grid[row - 1][col] !== '') { // 바로 위 칸이 비어있지 않다면
                // 이 칸이 배치하려는 단어의 일부(교차점)가 아니라면 false (중복 방지)
                if (grid[row - 1][col] !== word[0]) {
                    return false;
                }
            }
            if (row + word.length < size && grid[row + word.length][col] !== '') { // 바로 아래 칸이 비어있지 않다면
                // 이 칸이 배치하려는 단어의 일부(교차점)가 아니라면 false (중복 방지)
                if (grid[row + word.length][col] !== word[word.length - 1]) {
                    return false;
                }
            }
            
            // 3. 각 셀을 순회하며 충돌 검사
            for (let i = 0; i < word.length; i++) {
                const currentGridChar = grid[row + i][col];
                const newWordChar = word[i];

                if (currentGridChar !== '' && currentGridChar !== newWordChar) {
                    return false;
                }
                
                // 4. 수평 방향 인접 셀 검사
                if (currentGridChar === '') { 
                    // 왼쪽 셀 확인
                    if (col > 0 && grid[row + i][col - 1] !== '') {
                        return false;
                    }
                    // 오른쪽 셀 확인
                    if (col < size - 1 && grid[row + i][col + 1] !== '') {
                        return false;
                    }
                }
            }
            return true;
        }

        // 단어를 그리드에 배치하는 함수
        function placeWord(grid, word, placement) {
            if (placement.direction === 'across') { // 가로 방향
                for (let i = 0; i < word.length; i++) {
                    grid[placement.row][placement.col + i] = word[i];
                }
            } else { // 세로 방향 ('down')
                for (let i = 0; i < word.length; i++) {
                    grid[placement.row + i][placement.col] = word[i];
                }
            }
        }

        // 크로스워드를 HTML에 표시하는 함수
        function displayCrossword(grid, words, size) {
            const gridContainer = document.getElementById('crosswordGrid');
            const gridContainerMaxWidth = 450; // CSS에 설정된 .grid-container의 max-width
            const cellSize = gridContainerMaxWidth / size; 
            
            gridContainer.style.gridTemplateColumns = `repeat(${size}, ${cellSize}px)`;
            gridContainer.innerHTML = '';
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    // 동적으로 계산된 셀 크기를 적용합니다.
                    cell.style.width = `${cellSize}px`;
                    cell.style.height = `${cellSize}px`;
                    
                    if (grid[row][col] === '') {
                        cell.className += ' black'; // 검은 셀
                    } else { // 글자가 있거나 빈 플레이 가능 셀
                        cell.style.backgroundColor = 'white';
                        cell.style.border = '0.5px solid #ccc';
                        cell.textContent = grid[row][col] === ' ' ? '' : grid[row][col]; // ' ' 이면 빈 칸, 아니면 글자 표시
                    }
                    
                    gridContainer.appendChild(cell);
                }
            }
            
            // 단어 목록 표시
            document.getElementById('wordList').innerHTML = words.map(word => `<li>${word}</li>`).join('');
        }

        // 정답 보기/끄기 버튼 토글 함수
        function toggleAnswerView() {
            const toggleCheckbox = document.getElementById('answerToggleCheckbox');
            const toggleLabel = document.getElementById('toggleLabel');

            if (!currentGrid || !answerGrid) {
                toggleCheckbox.checked = false; // 퍼즐이 없으면 체크박스 초기화
                toggleLabel.textContent = '정답 보기';
                return;
            }

            showingAnswer = toggleCheckbox.checked; // 체크박스 상태를 따라감

            if (showingAnswer) {
                displayCrossword(answerGrid, currentWords, GRID_SIZE);
                toggleLabel.textContent = '정답 끄기';
            } else {
                displayCrossword(currentGrid, currentWords, GRID_SIZE);
                toggleLabel.textContent = '정답 보기';
            }
        }

        // 힌트 글자 하나를 공개하는 함수
        function revealHintLetterInternal() {
            const emptyPlayableCells = []; // 빈 칸의 좌표를 저장할 배열

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    // 현재 그리드에서는 빈 칸이면서, 정답 그리드에는 글자가 있는 칸만 선택
                    if (currentGrid[r][c] === ' ' && answerGrid[r][c] !== '') {
                        emptyPlayableCells.push({ row: r, col: c });
                    }
                }
            }

            if (emptyPlayableCells.length === 0) {
                return; // 더 이상 공개할 수 있는 빈 칸이 없으면 종료
            }

            // 무작위로 하나의 빈 칸 선택
            const randomIndex = Math.floor(Math.random() * emptyPlayableCells.length);
            const { row, col } = emptyPlayableCells[randomIndex];

            // 선택된 칸에 정답 글자 공개
            currentGrid[row][col] = answerGrid[row][col];
            
            // 현재 퍼즐 뷰를 보고 있을 때만 디스플레이를 업데이트
            if (!showingAnswer) {
                displayCrossword(currentGrid, currentWords, GRID_SIZE);
            }
        }


        // PDF로 다운로드하는 함수
        function downloadPDF() {
            if (!currentGrid || !currentWords || !answerGrid) {
                showModal('PDF를 다운로드할 크로스워드가 없습니다.');
                return;
            }
            
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            const size = GRID_SIZE; // 통일된 그리드 크기 사용
            
            // PDF에 한글을 지원하려면 한글 폰트를 임베드해야 합니다.
            // 이 예시는 영어에 적합한 기본 폰트를 사용합니다.
            // 만약 PDF에 한글 텍스트가 필수적이라면 다음을 추가해야 합니다:
            // doc.addFont('font-name.ttf', 'font-family', 'normal');
            // doc.setFont('font-family');
            
            // 제목
            doc.setFontSize(20);
            doc.text('Fill-in Crossword Puzzle', 105, 20, { align: 'center' });
            
            doc.setFontSize(12);
            doc.text('Fill in the empty squares using the words listed below.', 105, 30, { align: 'center' });
            
            // 퍼즐용 빈 그리드 그리기
            const puzzleStartX = 20;
            const puzzleStartY = 45; // Y 위치 조정
            const puzzleCellSize = 7; // PDF용 셀 크기 조정 (21x21 그리드)
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const x = puzzleStartX + col * puzzleCellSize;
                    const y = puzzleStartY + row * puzzleCellSize;
                    
                    if (currentGrid[row][col] === '') {
                        doc.setFillColor(0, 0, 0);
                        doc.rect(x, y, puzzleCellSize, puzzleCellSize, 'F');
                    } else {
                        doc.setFillColor(255, 255, 255);
                        doc.rect(x, y, puzzleCellSize, puzzleCellSize, 'FD');
                        // 힌트로 공개된 글자가 있다면 PDF 퍼즐에도 표시
                        if (currentGrid[row][col] !== ' ') {
                            doc.setFontSize(puzzleCellSize * 0.6); // 셀 크기에 비례하여 폰트 크기 조정
                            doc.text(currentGrid[row][col], x + puzzleCellSize * 0.1, y + puzzleCellSize * 0.75);
                        }
                    }
                }
            }
            
            // 단어 목록
            let wordsListStartY = puzzleStartY + size * puzzleCellSize + 20;
            doc.setFontSize(14);
            doc.text('Words to use:', puzzleStartX, wordsListStartY);
            wordsListStartY += 10;
            
            doc.setFontSize(10);
            let xPos = puzzleStartX;
            const wordsPerRow = 5; // 한 줄에 더 많은 단어를 위한 레이아웃 조정
            const wordColWidth = 35; // 단어의 열 너비 조정

            currentWords.forEach((word, index) => {
                if (index > 0 && index % wordsPerRow === 0) {
                    wordsListStartY += 8;
                    xPos = puzzleStartX;
                }
                
                doc.text(word, xPos, wordsListStartY);
                xPos += wordColWidth;
                
                // 내용이 넘치면 새 페이지 추가
                if (wordsListStartY > 270) {
                    doc.addPage();
                    wordsListStartY = 20;
                    xPos = puzzleStartX;
                }
            });
            
            // 정답 그리드 그리기 (새 페이지 하단 또는 공간이 있으면 같은 페이지에)
            if (wordsListStartY + 80 > 270) { // 공간이 충분한지 확인, 아니면 새 페이지 추가
                doc.addPage();
                wordsListStartY = 20; // 새 페이지를 위해 Y 재설정
            }
            const answerGridStartX = 20; // 시작 X 위치를 왼쪽으로 이동하여 더 크게 보이게 함
            const answerGridStartY = wordsListStartY + 20;
            const answerCellSize = 4.0; // 정답 키 셀 크기를 더 키움 (2.5 -> 4.0)
            
            doc.setFontSize(10); // 정답 그리드 제목 글자 크기
            doc.text('Answer:', answerGridStartX, answerGridStartY - 5);
            
            for (let row = 0; row < size; row++) {
                for (let col = 0; col < size; col++) {
                    const x = answerGridStartX + col * answerCellSize;
                    const y = answerGridStartY + row * answerCellSize;
                    
                    if (answerGrid[row][col] === '') {
                        doc.setFillColor(0, 0, 0);
                        doc.rect(x, y, answerCellSize, answerCellSize, 'F');
                    } else {
                        doc.setFillColor(255, 255, 255);
                        doc.rect(x, y, answerCellSize, answerCellSize, 'FD');
                        
                        doc.setFontSize(5); // 정답 글자를 위한 글꼴 크기 키움 (3.5 -> 5)
                        doc.text(answerGrid[row][col], x + answerCellSize * 0.25, y + answerCellSize * 0.7); // 셀 중앙에 가깝게 조정
                    }
                }
            }
            
            doc.save(`fill-in-crossword-${Date.now()}.pdf`);
        }

        // 페이지 로드 시 첫 번째 크로스워드 생성
        window.addEventListener('load', () => {
            generateCrossword();
        });
    </script>
</body>
</html>
